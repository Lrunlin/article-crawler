{"time":"2021-11-06T08:46:04.057Z","option":{"number":10,"image":false,"time":false,"keyword":false,"prohibited":false,"a":false,"type":"javascript"},"data":[{"title":"null","html":"<p>区块练DAPP软件开发，DAPP系统开发，云之梦科技有限公司专业的DAPP系统软件定制开发Tel15DAPP3331软件2713开发。<br>DAPP(Decentralized Application)是一种软件程序，旨在以一种不受任何单一实体控制的方式在互联网上存在。中文叫分布式应用/去中心化应用，不同的DAPP会采用不同的底层区块练开发平台(好比手机的IOS系统和Android系统)和共识机制，或者自行发布代币，也有基于相同区块练平台的通用代币。<br>DAPP区块练，出现在以太坊，EOS等新晋分布式途径或网络上，不依赖任何中心服务器，完成去中心化的目的。DAPP与PC和手机上的传统APP不同，强调去中心化，有必要运行在分布式的操作系统，而不能作业在iOS及Android这些传统途径上。<br>云之梦专业的DAPP系统软件定制开发公司哪家专业，DAPP盘绕区块练，使用程序有必要开源，有必要有鼓舞原则，就是Token，即代币或通证，根据商场反应，经大都用户附和后进行改进。<br>对比APP来看，最大不同是中心化与去中心化，App先是要有钱，所以先融资，然后再有人，所以先招齐人，然后再开发运营，所以先成立一个团队一家公司;而DAPP则是继承传统App之下发展，结合区块练的特点所形成的产物，它更像是众筹模式，共享模式和去中心化模式，先有发起人或组织，写好白皮书明确了共识机制和token分配与激励，开发好应用再是持有token的人即为股东，直接和app的盈利关联，也可以说用户即是股东，持有的token像股票可以买卖，在支持的交易所交易。所以持有该DAPP的token相当于拥有所有者权益，可以想象未来，现在是处处琳琅满目的App应用，未来是各个领域都会有DAPP，每个人都将因token分类以token群分。<br>DAPP应用市场<br>虽说DAPP没有飞入寻常百姓家，没有达到绝大多数人手机安装DAPP的地步，但DAPP的发展已经在路上。如果关注币圈，链圈或者投资虚拟数字货币的话，相信都用过数字货币钱包如比特派，imToken，而钱包是一款应用，直接与你数字货币绑定。随之而来，是挖矿的应用如我们公司与长虹合作在开发的挖矿应用，包括市面上前段时间讨论最多的公信宝和网易星球。下面来罗列一下目前市面上看得到的DAPP应用。<br>我司开发DAPP，提供去中心化应用落地开发和分发服务。Tel15DAPP3331软件2713开发<br>【加密宠物】通过区块练技术，实现虚拟宠物的收藏，养成，交易，繁殖与竞技等。<br>【加密资产】基于区块练的虚拟星球，国家或城市，可进行交易，收藏管理。<br>【广告平台】基于智能合约的糖果分发广告平台，项目方可投放糖果来获取平台流量。<br>区块练DAPP软件开发多少钱，云之梦专业的DAPP系统软件定制开发，区块练技术在各个项目中的应用，可以搭建全新生态体系，分布式数据存储，点对点传输共同机制，加密算法等计算机技术的新式使用方式，彻底杜绝了黑箱操作，构建公平游戏环境。</p>","type":["javascript","前端","vue.js","html"],"time":"2021-11-06T08:13:43.000Z","href":"https://segmentfault.com/a/1190000040920281"},{"title":"null","html":"<p>一，前言<br>​ 今天总结一下关于Java的三大特性，封装，继承，多态。其实关于三大特性对于从事编程人员来说都是基本的了，毕竟只要接触Java这些都是先要认识的，接下来就系统总结一下。</p><p>二，封装<br>​ 先来说说特性之一：封装</p><p>2.1，什么是封装<br>​ 封装（Encapsulation）是面向对象方法的重要原则，就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。</p><p>将类的某些信息隐藏在类的内部，不允许外部程序进行直接的访问调用。<br>通过该类提供的方法来实现对隐藏信息的操作和访问。<br>隐藏对象的信息。<br>留出访问的对外接口。<br>​ 举个比较通俗的例子，比如我们的USB接口。如果我们需要外设且只需要将设备接入USB接口中，而内部是如何工作的，对于使用者来说并不重要。而USB接口就是对外提供的访问接口。</p><p>​ 说了这么多，那为什么使用封装？</p><p>2.2，封装的特点<br>对成员变量实行更准确的控制。<br>封装可以隐藏内部程序实现的细节。<br>良好的封装能够减少代码之间的耦合度。<br>外部成员无法修改已封装好的程序代码。<br>方便数据检查，有利于保护对象信息的完整性，同时也提高程序的安全性。<br>便于修改，体高代码的可维护性。<br>2.3，封装的使用<br>使用private修饰符，表示最小的访问权限。</p><p>对成员变量的访问，统一提供setXXX，getXXX方法。</p><p>下面请看一个Student实体对象类：</p><p>public class Student implements Serializable {</p><pre><code>\nprivate Long id;\nprivate String name;\nprivate Integer sex;\n\npublic Long getId() {\n    return id;\n}\n\npublic void setId(Long id) {\n    this.id = id;\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic Integer getSex() {\n    return sex;\n}\n\npublic void setSex(Integer sex) {\n    this.sex = sex;\n}</code></pre><p>}</p><p>分析：对于上面的一个实体对象，我想大家都已经很熟悉了。将对象中的成员变量进行私有化，外部程序是无法访问的。但是我们对外提供了访问的方式，就是set和get方法。</p><p>​ 而对于这样一个实体对象，外部程序只有赋值和获取值的权限，是无法对内部进行修改，因此我们还可以在内部进行一些逻辑上的判断等，来完成我们业务上的需要。</p><p>​ 到这里应该就明白封装对于我们的程序是多么重要。下面再来说说继承的那点事。</p><p>三，继承<br>3.1，什么是继承<br>​ 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。当然，如果在父类中拥有私有属性(private修饰)，则子类是不能被继承的。</p><p>3.2，继承的特点<br>1，关于继承的注意事项：</p><p>​ 只支持单继承，即一个子类只允许有一个父类，但是可以实现多级继承，及子类拥有唯一的父类，而父类还可以再继承。</p><p>​ 子类可以拥有父类的属性和方法。</p><p>​ 子类可以拥有自己的属性和方法。</p><p>​ 子类可以重写覆盖父类的方法。</p><p>2，继承的特点：</p><p>提高代码复用性。</p><p>父类的属性方法可以用于子类。</p><p>可以轻松的定义子类。</p><p>使设计应用程序变得简单。<br>3.3，继承的使用<br>​ 1，在父子类关系继承中，如果成员变量重名，则创建子类对象时，访问有两种方式。</p><p>a，直接通过子类对象访问成员变量</p><p>​ 等号左边是谁，就优先使用谁，如果没有就向上找。</p><p>b，间接通过成员方法访问成员变量</p><p>该方法属于谁，谁就优先使用，如果没有就向上找。</p><p>public class FU {</p><pre><code>int numFU = 10;\nint num = 100;\npublic void method(){\n    System.out.println(\"父类成员变量：\"+numFU);\n}\npublic void methodFU(){\n    System.out.println(\"父类成员方法!\");\n}</code></pre><p>}<br>public class Zi extends FU{</p><pre><code>int numZi = 20;\nint num = 200;\npublic void method(){\n    System.out.println(\"子类成员变量：\"+numFU);\n}\npublic void methodZi(){\n    System.out.println(\"子类方法！\");\n}</code></pre><p>}<br>public class ExtendDemo {</p><pre><code>public static void main(String[] args) {\n    FU fu = new FU();\n    // 父类的实体对象只能调用父类的成员变量\n    System.out.println(\"父类：\" + fu.numFU);   // 结果：10\n    \n    Zi zi = new Zi();\n    System.out.println(\"调用父类：\" + zi.numFU); // 结果：10\n    System.out.println(\"子类：\" + zi.numZi);   // 结果：20\n\n    /** 输出结果为200，证明在重名情况下，如果子类中存在则优先使用，\n     *  如果不存在则去父类查找，但如果父类也没有那么编译期就会报错。\n     */\n    System.out.println(zi.num); // 结果：200\n    /**\n     * 通过成员方法调用成员变量\n     */\n    zi.method();    // 结果：10\n}</code></pre><p>}<br>2，同理：</p><p>​ 成员方法也是一样的，创建的对象是谁，就优先使用谁，如果没有则直接向上找。<br>​ 注意事项：</p><p>​ 无论是成员变量还是成员方法，如果没有都是向上父类中查找，绝对不会向下查找子类的。</p><p>3，在继承关系中，关于成员变量的使用：</p><p>​ 局部成员变量：直接使用<br>​ 本类成员变量：this.成员变量<br>​ 父类成员变量：super.父类成员变量</p><p>int numZi = 10;<br> public void method() {<br>   int numMethod = 20;<br>   System.out.println(numMethod);  // 访问局部变量<br>   System.out.println(this.numZi); // 访问本类成员变量<br>   System.out.println(super.numFu); // 访问本类成员变量<br>}<br>3.4，重写，重载<br>​ 重写(override)</p><p>​ 是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</p><p>class Animal{<br>   public void move(){</p><pre><code>  System.out.println(\"动物行走！\");</code></pre><p>}<br>}</p><p>class Dog extends Animal{<br>   public void move(){</p><pre><code>  System.out.println(\"狗可以跑和走\");</code></pre><p>}<br>}</p><p>public class TestDog{<br>   public static void main(String args[]){</p><pre><code>  Animal a = new Animal(); // Animal 对象\n  Animal b = new Dog(); // Dog 对象\n  a.move();// 执行 Animal 类的方法\n  b.move();//执行 Dog 类的方法</code></pre><p>}<br>}<br>​ 重写的规则：</p><p>​ 1，参数列表必须与被重写方法相同。</p><p>​ 2，访问权限不能比父类中被重写的方法的访问权限更低（public&gt;protected&gt;(default)&gt;private）。</p><p>​ 3，父类成员的方法只能被它的子类重写。</p><p>​ 4，被final修饰的方法不能被重写。</p><p>​ 5，构造方法不能</p><p>重载(overload)</p><p>​ 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>​ 最常用的地方就是构造器的重载。</p><p>public class Overloading {</p><pre><code>   public int test(){\n       System.out.println(\"test1\");\n       return 1;\n   }\n   public void test(int a){\n       System.out.println(\"test2\");\n   }   \n   //以下两个参数类型顺序不同\n   public String test(int a,String s){\n       System.out.println(\"test3\");\n       return \"returntest3\";\n   }   \n   public String test(String s,int a){\n       System.out.println(\"test4\");\n       return \"returntest4\";\n   }    \n   public static void main(String[] args){\n       Overloading o = new Overloading();\n       System.out.println(o.test());\n       o.test(1);\n       System.out.println(o.test(1,\"test3\"));\n       System.out.println(o.test(\"test4\",1));\n   }</code></pre><p>}<br>​ 重载规则：</p><p>​ 1，被重载的方法必须改变参数列表（参数个数或者类型不一样）。</p><p>​ 2，被重载的方法可以改变返回类型。</p><p>​ 3，被重载的方法可以改变访问修饰符。</p><p>3.5，this，super关键字<br>super()关键字的用法<br>​ 1，子类的成员方法中，访问父类的成员变量。</p><p>​ 2，子类的成员方法中，访问父类的成员方法。<br>3，子类的构造方法中，访问父类的构造方法。</p><p>this关键字用法：<br>​ 1，本类成员方法中，访问本类的成员变量。<br>​ 2，本类成员方法中，访问本类的另一个成员方法。<br>3，本类的构造方法中，访问本类的另一个构造方法。<br>​ 注意：</p><p>this关键字同super一样，必须在构造方法的第一个语句，且是唯一的。<br>this与super不能同时存在。<br>3.6，构造器<br>​ 继承关系中，父子类构造方法的访问特点：<br>​ 1，在子类构造方法中有一个默认隐含的super();调用，因此一定是先调用父类构造方法，再调用子类构造方法。<br>​ 2，子类构造可以通过super();调用父类的重载构造。(重载)<br>​ 3，super();的父类调用构造方法，必须在子类构造中的第一行，就是第一个;号结束的元素，并且只能调用一次。</p><p>3.7，关于继承的注意事项：<br>​ 1，Java语言是单继承的，一个子类只能有唯一一个父类<br>​ 2，Java语言可以是多级继承，一个子类有一个父类，一个父类还可以有一个父类。<br>​ 3，一个子类只有一个父类，但是一个父类可以有多个子类。</p><p>四，多态<br>4.1，什么是多态<br>​ 多态是同一个行为具有多个不同表现形式或形态的能力。</p><p>4.2，多态的特点<br>​ 1，消除类型之间的耦合关系，实现低耦合。</p><p>​ 2，灵活性。</p><p>​ 3，可扩充性。</p><p>​ 4，可替换性。</p><p>4.3，多态的体现形式<br>继承</p><p>父类引用指向子类</p><p>重写</p><p>​ 注意：在多态中，编译看左边，运行看右边</p><p>public class MultiDemo {</p><pre><code>   public static void main(String[] args) {\n       // 多态的引用，就是向上转型\n       Animals dog = new Dog();\n       dog.eat();\n       \n       Animals cat = new Cat();\n       cat.eat();\n       \n       // 如果要调用父类中没有的方法，则要向下转型\n       Dog dogDown = (Dog)dog;\n       dogDown.watchDoor();\n\n   }</code></pre><p>}<br>   class Animals {</p><pre><code>   public void eat(){\n       System.out.println(\"动物吃饭！\");\n   }</code></pre><p>}<br>   class Dog extends Animals{</p><pre><code>   public void eat(){\n       System.out.println(\"狗在吃骨头！\");\n   }\n   public void watchDoor(){\n       System.out.println(\"狗看门！\");\n   }</code></pre><p>}<br>   class Cat extends Animals{</p><pre><code>   public void eat(){\n       System.out.println(\"猫在吃鱼！\");\n   }</code></pre><p>}<br>4.4，向上转型<br>1，格式：父类名称 对象名 = new 子类名称();</p><pre><code>  含义：右侧创建一个子类对象，把它当作父类来使用。\n  注意：向上转型一定是安全的。\n  缺点：一旦向上转型，子类中原本特有的方法就不能再被调用了。    \n\n</code></pre><p>五，接口<br>​ 最后，关于接口方面的细节，不同版本之间的区别。</p><p>问题描述：</p><p>​ 现在接口中需要抽取一个公有的方法，用来解决默认方法中代码重复的问题。<br>​ 但是这个共有的方法不能让实现类实现，所以应该设置为私有化。</p><p>在JDK8之后：</p><p>​ 1，default修饰，接口里允许定义默认的方法，但默认方法也可以覆盖重写。<br>​ 2，接口里允许定义静态方法。</p><p>在JDK9之后：</p><p>​ 1，普通私有方法，解决多个默认方法之间代码重复的问题。<br>​ 2，静态私有化，解决多个静态方法之间代码重复问题。<br>​ 接口的注意事项：<br>​ 1，不能通过接口的实现类对象去调用接口中的静态方法。<br>​ 正确语法：接口名称调用静态方法。</p><p>接口当中的常量的使用：</p><p>​ 1，接口当中定义的常量：可以省略public static final。<br>​ 2，接口当中定义的常量：必须进行赋值。<br>​ 3，接口当中定义的常量：常量的名称要全部大写，多个名称之间使用下划线进行分割。</p><p>使用接口的注意事项：</p><p>​ 1，接口是没有静态代码块或者构造方法<br>​ 2，一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。<br>​ 3，如果实现类没有覆盖重写接口中所有的抽象方法，那么实现类就必须是一个抽象类<br>​ 4，如果实现类中实现多个接口，存在重复的抽象方法，那么只需要覆盖重写一次即可。<br>​ 5，在Java中，如果实现类的直接继承父类与实现接口发生冲突时，父类优先级高于接口。</p><p>接口之间的关系：</p><p>​ 1，多个接口之间是继承关系。<br>​ 2，多个父接口当中默认方法如果重复，那么子接口必须进行默认方法的覆盖重写。</p><p>六，总结<br>​ 关于Java的特性基本总结完毕，当然还有一些细节没有完善。其实对于这些Java基础一定要掌握并熟记，因为这与我们的实际开发密切相关，好的编码习惯才能铸就好的产品，才能被社会认可。</p>","type":["javascript"],"time":"2021-11-06T07:18:09.000Z","href":"https://segmentfault.com/a/1190000040920107"},{"title":"null","html":"<p>在程序设计过程中，读者很可能遇到这样一种困境：设计了一个接口，但实现这个接口的子类并不需要实现接口中的全部方法，也就是说，接口中的方法过多，对于某些子类是多余的，我们不得不浪费的写上一个空的实现。</p><pre><code>   今天小菜提到的“抽象接口”，就是用来解决这个问题的。\n\n   为了不误导读者，先说明一下，什么是“抽象接口”。\n\n   所谓“抽象接口”，即在提供接口的同时，提供一个抽象类，用抽象类实现该接口(实际上这是缺省适配模式)。\n\n   下面小菜举个例子，让读者体会这样做的好处。\n\n   代码写的不咋地，为了防止读者看不懂，先上一张类图：\n\n\n</code></pre><p>具体代码：</p><p>　　ITestInterface.java</p><p>复制代码<br>1 /*<br>2     假设有一个顶层接口<br>3 */<br>4 public interface ITestInterface{<br>5     void method1();<br>6     int method2();<br>7     boolean method3();<br>8 }<br>复制代码</p><p>　　TestAbstract.java</p><p>复制代码<br> 1 /*<br> 2     抽象类abstract实现了ITestInterface顶层接口<br> 3 */<br> 4 <br> 5 public abstract class TestAbstract implements ITestInterface{<br> 6     //找出接口中必要的方法，也就是子类必须实现的方法，定义成抽象方法，交由子类实现<br> 7     public abstract void method1();<br> 8     public abstract int method2();<br> 9     <br>10     //一些独特的方法可以在抽象类中默认实现<br>11     public boolean method3(){<br>12         return true;<br>13     }<br>14 }<br>复制代码</p><p>　　</p><p>　　TestClass1.java</p><p>复制代码<br> 1 /*<br> 2     普通类TestClass1继承了TestAbstract抽象类<br> 3 */<br> 4 <br> 5 public class TestClass1 extends TestAbstract{<br> 6     <br> 7     //TestClass1必须实现抽象的method1方法，该方法最早是接口中定义的<br> 8     public void method1(){<br> 9         <br>10     }<br>11     //TestClass1必须实现抽象的method2方法，该方法最早是接口中定义的<br>12     public int method2(){<br>13         return 1;<br>14     }<br>15     <br>16     //接口中的method3方法对于TestClass1无关紧要，因此不做重写。<br>17 }<br>复制代码</p><p>　　TestClass2.java</p><p>复制代码<br> 1 /*<br> 2     普通类TestClass2继承了TestAbstract抽象类<br> 3 */<br> 4 <br> 5 public class TestClass2 extends TestAbstract{<br> 6     <br> 7     //TestClass2必须实现抽象的method1方法，该方法最早是接口中定义的<br> 8     public void method1(){<br> 9     <br>10     }<br>11     //TestClass2必须实现抽象的method2方法，该方法最早是接口中定义的<br>12     public int method2(){<br>13         return 2;<br>14     }<br>15     <br>16     //method3方法对于TestClass2来说至关重要，因此必须重写。<br>17     public boolean method3(){<br>18         return false;<br>19     }<br>20     <br>21 }<br>复制代码</p><p>代码精讲：</p><p>　　　　从以上例子可以看出，最高层的接口被一个抽象类实现，在抽象类中，我们把关键的method1、method2方法定义成抽象方法，强制子类去实现，而“独特”的method3方法在抽象类中做一个默认实现。</p><p>　　　　等到TestClass1、TestClass2继承TestAbstract抽象类时，优势就体现出来了，TestClass1、TestClass2必须实现method1、method2，但如果用不到method3，可以直接无视。</p><p>　　　　通过接口和抽象类的结合，避免了在实现接口的子类中出现大量的“无意义”实现，这个“无意义”实现，被缓冲到了抽象类中，完美展现了代码复用（可以把抽象类理解成接口和实现类之间的缓冲）。</p><p>　　　　需要指出的是，我们既可以选择继承抽象类，也可以选择实现接口，并不是说一定要继承抽象类，看情况而定，这里是两种选择，两个机会。</p><pre><code>  \n\n          写到这，或许读者觉得文章已经结束了，其实没有。。。\n\n          这样做的好处不仅仅是这一点，细细品味，假如我们向接口中增加了一个方法。。。\n\n\n</code></pre><p>具体代码：</p><p>　　温馨提示：不要被代码吓到，其实这些代码和上边的差不多，只不过加了个方法而已。</p><p>　　ITestInterface.java</p><p>复制代码<br> 1 /*<br> 2     假设有一个顶层接口<br> 3 */<br> 4 public interface ITestInterface{<br> 5     void method1();<br> 6     int method2();<br> 7     boolean method3();<br> 8     //接口中新增加了方法<br> 9     String method4();<br>10 }<br>复制代码</p><p>　　TestAbstract.java</p><p>复制代码<br> 1 /*<br> 2     抽象类abstract实现了ITestInterface顶层接口<br> 3 */<br> 4 <br> 5 public abstract class TestAbstract implements ITestInterface{<br> 6     //找出接口中必要的方法，也就是子类必须实现的方法，定义成抽象方法，交由子类实现<br> 7     public abstract void method1();<br> 8     public abstract int method2();<br> 9     <br>10     //一些独特的方法可以在抽象类中默认实现<br>11     public boolean method3(){<br>12         return true;<br>13     }<br>14     <br>15     //抽象类中提供一个默认实现，这样就可以避免\"惊动\"所有子类<br>16     public String method4(){<br>17         return \"\";<br>18     }<br>19 }<br>复制代码</p><p>　　TestClass1.java</p><p>复制代码<br> 1 /*<br> 2     普通类TestClass1继承了TestAbstract抽象类<br> 3 */<br> 4 <br> 5 public class TestClass1 extends TestAbstract{<br> 6     <br> 7     //TestClass1必须实现抽象的method1方法，该方法最早是接口中定义的<br> 8     public void method1(){<br> 9         <br>10     }<br>11     //TestClass1必须实现抽象的method2方法，该方法最早是接口中定义的<br>12     public int method2(){<br>13         return 1;<br>14     }<br>15     <br>16     //接口中的method3方法对于TestClass1无关紧要，因此不做重写。<br>17     <br>18     //新增的方法对于TestClass1来说至关重要，因此必须重写<br>19     public String method4(){<br>20         return \"Class1\";<br>21     }<br>22 <br>23 }<br>复制代码</p><p>　　TestClass2.java</p><p>复制代码<br> 1 /*<br> 2     普通类TestClass2继承了TestAbstract抽象类<br> 3 */<br> 4 <br> 5 public class TestClass2 extends TestAbstract{<br> 6     <br> 7     //TestClass2必须实现抽象的method1方法，该方法最早是接口中定义的<br> 8     public void method1(){<br> 9     <br>10     }<br>11     //TestClass2必须实现抽象的method2方法，该方法最早是接口中定义的<br>12     public int method2(){<br>13         return 2;<br>14     }<br>15     <br>16     //method3方法对于TestClass2来说至关重要，因此必须重写。<br>17     public boolean method3(){<br>18         return false;<br>19     }<br>20     <br>21     //新增的方法对于TestClass2来说无关紧要，无需知道新增method4的存在<br>22 }<br>复制代码</p><p>代码精讲：</p><p>　　　　这段代码演示了假如项目已经成型，但是需求有变，我们不得不向接口中增加一个新的方法，假如子类直接实现了接口，那么这些子类都要修改，来实现接口新增的方法。</p><p>　　　　但本例中的TestClass1、TestClass2子类没有直接实现接口，而是通过继承抽象类间接实现接口，这样好处一下就体现出来了！</p><p>　　　　向接口中新增的方法，可以在实现接口的抽象类中缓冲一下，提供一个默认的实现，这样一来，就不必强制所有的子类(通过继承抽象类间接实现接口的类)都进行修改，可以形象的理解为“没有惊动子类”。而需要使用这个方法的子类，直接重写即可。</p><p>小菜感慨：</p><p>　　　　人类的智慧真伟大！数组和链表结合，产生了高效的哈希表；接口和抽象类结合，产生了优雅的缺省适配模式。大家努力吧！！！</p><p>写在后面的话：</p><p>　　　　世间没有完美的事物，设计模式也是如此，过多的讨论优缺点没有意义，合适的就是最好的，什么是合适的呢？这才是体现智慧的地方。</p>","type":["javascript","html"],"time":"2021-11-06T07:16:12.000Z","href":"https://segmentfault.com/a/1190000040920102"},{"title":"null","html":"<p>在读很多并发文章中，会提及各种各样锁如公平锁，乐观锁等等，这篇文章介绍各种锁的分类。介绍的内容如下：</p><p>公平锁/非公平锁<br>可重入锁<br>独享锁/共享锁<br>互斥锁/读写锁<br>乐观锁/悲观锁<br>分段锁<br>偏向锁/轻量级锁/重量级锁<br>自旋锁<br>上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。</p><p>公平锁/非公平锁<br>公平锁是指多个线程按照申请锁的顺序来获取锁。<br>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。<br>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><p>可重入锁<br>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。<br>对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。<br>对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p><p>synchronized void setA() throws Exception{</p><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"Thread.sleep(1000);\nsetB();\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"hljs language-abnf\">Thread.sleep(<span class=\"hljs-number\">1000</span>)<span class=\"hljs-comment\">;</span>\nsetB()<span class=\"hljs-comment\">;</span></pre><p>}</p><p>synchronized void setB() throws Exception{</p><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"Thread.sleep(1000);\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"hljs language-abnf\">Thread.sleep(<span class=\"hljs-number\">1000</span>)<span class=\"hljs-comment\">;</span></pre><p>}<br>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。</p><p>独享锁/共享锁<br>独享锁是指该锁一次只能被一个线程所持有。<br>共享锁是指该锁可被多个线程所持有。</p><p>对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。<br>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。<br>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<br>对于Synchronized而言，当然是独享锁。</p><p>互斥锁/读写锁<br>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。<br>互斥锁在Java中的具体实现就是ReentrantLock<br>读写锁在Java中的具体实现就是ReadWriteLock</p><p>乐观锁/悲观锁<br>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。<br>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。<br>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p><p>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。<br>悲观锁在Java中的使用，就是利用各种锁。<br>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</p><p>分段锁<br>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。<br>我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。<br>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。<br>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。<br>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><p>偏向锁/轻量级锁/重量级锁<br>这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。<br>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。<br>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。<br>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><p>自旋锁<br>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。<br>典型的自旋锁实现的例子，可以参考自旋锁的实现</p>","type":["javascript","java"],"time":"2021-11-05T12:14:16.000Z","href":"https://segmentfault.com/a/1190000040918196"},{"title":"null","html":"<p>一、什么是AES？<br>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），是一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。</p><p>那么为什么原来的DES会被取代呢，，原因就在于其使用56位密钥，比较容易被破解。而AES可以使用128、192、和256位密钥，并且用128位分组加密和解密数据，相对来说安全很多。完善的加密算法在理论上是无法破解的，除非使用穷尽法。使用穷尽法破解密钥长度在128位以上的加密数据是不现实的，仅存在理论上的可能性。统计显示，即使使用目前世界上运算速度最快的计算机，穷尽128位密钥也要花上几十亿年的时间，更不用说去破解采用256位密钥长度的AES算法了。</p><p>目前世界上还有组织在研究如何攻破AES这堵坚厚的墙，但是因为破解时间太长，AES得到保障，但是所用的时间不断缩小。随着计算机计算速度的增快，新算法的出现，AES遭到的攻击只会越来越猛烈，不会停止的。</p><p>AES现在广泛用于金融财务、在线交易、无线通信、数字存储等领域，经受了最严格的考验，但说不定哪天就会步DES的后尘。</p><p>二、AES加密方式简析</p><ul><li>AES加密是对称加密 128 192 256 分别表示密钥的长度</li><li><p>AES的加密方式会将明文拆分成不同的块进行加密，例如一个256 位的数据用128的密钥加密，则分成</p><p>明文1（128位）    明文2（128位）</p><p>加密</p><p>密文1（128位）    密文2（128位）</p></li></ul><p>填充：<br>　　如果明文不是128位（16字节）的则需要填充，即在明文某个地方补充到16个字节整数倍的长度，加解密时需要采用同样的填充方式，否则无法解密成功，以下是几种填充方式</p><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"** NoPadding\n不进行填充，但是这里要求明文必须要是16个字节的整数倍，这个可以使用者本身自己去实现填充，除了该种模式以外的其他填充模式，如果已经是16个字节的数据的话，会再填充一个16字节的数据\n\n** PKCS5Padding（默认）\n在明文的末尾进行填充，填充的数据是当前和16个字节相差的数量，例如：\n  未填充明文\n1，2，3，4，5，6，7，8，9，10，11\n\n  填充明文（缺少五个满足16个字节）\n1，2，3，4，5，6，7，8，9，10，11，5，5，5，5，5\n\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"hljs language-dns\">** NoPadding\n不进行填充，但是这里要求明文必须要是<span class=\"hljs-number\">16</span>个字节的整数倍，这个可以使用者本身自己去实现填充，除了该种模式以外的其他填充模式，如果已经是<span class=\"hljs-number\">16</span>个字节的数据的话，会再填充一个<span class=\"hljs-number\">16</span>字节的数据\n\n** PKCS5Padding（默认）\n在明文的末尾进行填充，填充的数据是当前和<span class=\"hljs-number\">16</span>个字节相差的数量，例如：\n  未填充明文\n<span class=\"hljs-number\">1，2，3，4</span>，<span class=\"hljs-number\">5，6，7，8</span>，<span class=\"hljs-number\">9</span>，<span class=\"hljs-number\">10</span>，<span class=\"hljs-number\">11</span>\n\n  填充明文（缺少五个满足<span class=\"hljs-number\">16</span>个字节）\n<span class=\"hljs-number\">1，2，3，4</span>，<span class=\"hljs-number\">5，6，7，8</span>，<span class=\"hljs-number\">9，10，11，5</span>，<span class=\"hljs-number\">5，5，5，5</span>\n</pre><p>　由于使用PKCS7Padding/PKCS5Padding填充时，最后一个字节肯定为填充数据的长度，所以在解密后可以准确删除填充的数据</p><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"** ISO10126Padding\n在明文的末尾进行填充，当前和16个字节相差的数量填写在最后，其余字节填充随机数，例如：\n  未填充明文\n1，2，3，4，5，6，7，8，9，10，11\n\n  填充明文（缺少五个满足16个字节）\n1，2，3，4，5，6，7，8，9，10，11，c，b，4，1，5\n\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"hljs language-dns\">** ISO10126Padding\n在明文的末尾进行填充，当前和<span class=\"hljs-number\">16</span>个字节相差的数量填写在最后，其余字节填充随机数，例如：\n  未填充明文\n<span class=\"hljs-number\">1，2，3，4</span>，<span class=\"hljs-number\">5，6，7，8</span>，<span class=\"hljs-number\">9</span>，<span class=\"hljs-number\">10</span>，<span class=\"hljs-number\">11</span>\n\n  填充明文（缺少五个满足<span class=\"hljs-number\">16</span>个字节）\n<span class=\"hljs-number\">1，2，3，4</span>，<span class=\"hljs-number\">5，6，7，8</span>，<span class=\"hljs-number\">9</span>，<span class=\"hljs-number\">10</span>，<span class=\"hljs-number\">11</span>，c，b，<span class=\"hljs-number\">4</span>，<span class=\"hljs-number\">1</span>，<span class=\"hljs-number\">5</span>\n</pre><p>模式<br>　　模式是需要制定AES对明文进行加密时使用的模式（这里并不涉及具体的加密方法，只是加密步骤上的不同模式，在加解密时同样需要相同的模式，否则无法成功），一共提供了五种模式，模式的基本原理是近似的，但是细节上会有一些变化，如下：</p><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"** ECB模式（默认）电码本模式 Electronic Codebook Book\n\n这个模式是默认的，就只是根据密钥的位数，将数据分成不同的块进行加密，加密完成后，再将加密后的数据拼接起来，过程如下：\n\n明文（64字节） 密钥（16字节）\n\n明文1（16字节）  明文2（16字节）  明文3（16字节）  明文4（16字节）\n\n密文1（16字节）  密文2（16字节）  密文3（16字节）  密文4（16字节）\n\n密文（64字节）\n\n优点：简单、速度快、可并行\n缺点：如果明文块相同，则生成的密文块也相同，这样会导致安全性降低\n\n\n** CBC模式   密码分组链接模式 Cipher Block Chaining\n\n为了解决ECB模式的密文块相同的缺点，CBC的模式引入了一个初始向量概念，该向量必须是一个与密钥长度相等的数据，在第一次加密前，会使用初始化向量与第一块数据做异或运算，生成的新数据再进行加密，加密第二块之前，会拿第一块的密文数据与第二块明文进行异或运算后再进行加密，以此类推，解密时也是在解密后，进行异或运算，生成最终的明文。过程如下：\n\n明文（63字节） 密钥 （16字节） 初始向量iv（16字节）\n\n  明文1（16字节） 明文2（16字节） 明文3（16字节） 明文4+一个0（16字节） \n\n异或  +初始向量        +密文1         +密文2         +密文3\n\n  密文1（16字节） 密文2（16字节） 密文3（16字节） 密文4（16字节） \n\n密文（64字节）\n\n这里需要注意如下几点：\n1.向量必须是一个与密钥长度相等的数据\n2.由于在加密前和解密后都会做异或运算，因此我们的明文可以不用补全，不是16个字节的倍数也可以，CBC中会自动用0补全进行异或运算\n3.在解密时是解密后才会再做异或运算，保证数据解密成功\n4.由于自动进行了补全，所以解密出的数据也会在后面补全0，因此获取到数据时，需要将末尾的0去除，或者根据源数据长度来截取解密后的数据\n\n优点：每次加密密钥不同，加强了安全性\n\nCBC的方式解决了EBC的缺点，但是也有其缺点：\n1.加密无法并行运算，但是解密可以并行，必须在前一个块加密完成后，才能加密后块，并且也需要填充0在后面，所以并不适合流数据（不适合的原因可能是，需要满足128位的数据之后才能进行加密，这样后面才不会有0的补全）\n2.如果前一个数据加密错误，那么后续的数据都是错的了\n3.两端需要同时约定初始向量iv\n\n\n** CFB模式： 密码反馈模式 Cipher FeedBack\n这个模式只使用了加密方法，原理是用到了一个数值异或运算之后再进行一次异或运算，值不改变的原理。并且在加密的时候，如果数据并不满足一个密钥的字节，那么只做保存，待满足一个密钥的字节后再进行加密 过程如下：\n\n加密：\n\n明文（260个字节） iv（128个字节）\n\n明文1（128个字节）    明文2（128个字节）      明文3（4个字节）\n\n（iv+key）异或 明文1 （密文1+key）异或 明文1  （密文1+key）异或明文3\n\n密文1（128个字节）     密文2（128个字节）      密文3（4个字节）\n\n\n解密：\n\n密文（260个字节） iv（128个字节）密钥（128字节）\n\n密文1（128个字节）      密文2（128个字节）      密文3（4个字节）\n\n（iv+key）异或密文1   （密文1+key）异或密文2    （密文1+key）异或密文3\n\n明文1 （128个字节）     明文2  （128个字节）      明文3（4个字节）\n\n这里需要注意如下几点：\n1.加解密时会返回一个num，这个num表示还需要几个数字，才会使用上一个密文加密，否则一直使用上上一个\n2.加解密时也需要传入字符串的长度\n3.由于解密时使用的都是密文来进行解密，并没有使用上一次解密的明文，因此解密也可以并行\n4.由于CFB模式并不需要补全，或者一个完整的128字节才能加解密，综合第三点，所以适合流数据的传输。\n5.CFB模式不止有CFB128（即与密钥长度一致），还有CFB1 和CFB8 即加解密1或8位后，再调用一次加密器生成新的值，这样可以使加密更安全，但是就会处理更多的运算，CFB1的运算时间是CFB8的八倍 CFB128的128倍\n6.使用CFB128或者CFB8的时候传入的length单位是字节，CFB1是length的单位是位。\n7.使用CFB1和CFB8的时候，num值会始终为0\n\n优点:解密可同步，可以传入非16字节倍数的数据，适合流数据\n\nCFB模式当然也有一个缺点，解密的时候可以并行解密，但是加密的时候并不可以并行加密。并且也需要选择iv\n\n\n** OFB模式： 输出反馈模式 Output FeedBack\n该模式与CFB类似，但是是将iv或者上一个iv加密后的数据加密，生成的key与明文做异或运算，解密时采用的是同样的方法，利用了异或运算的对称性来进行加解密，除了这一点，其余与CFB一致\n\n加密/解密：\n\nCFB:\n（iv+key）异或 明文1 （密文1+key）异或 明文1       （密文1+key）异或明文3\n\nOFB\n（iv+key)异或明文1 （（iv+key）+key)异或明文1  （（（iv+key）+key）+key）异或明文3\n\n优点：与CFB一样，方便传输流数据\n\n缺点：由于依赖上一次的加密结果，所以并不能并行处理，特性是解密步骤完全一致，因此使用方法上不会有区别。\n\n\n** CTR模式： 计算器模式 Counter\nOFB不能并行的原因就在于需要上一次的iv进行加密后的结果，因此在CTR中我们将（iv+key）+key替换成了（iv+1）+key,这样我们就不需要依赖上一次的加密结果了。对比如下:\n\nOFB\n（iv+key)异或明文1 （（iv+key）+key)异或明文1  （（（iv+key）+key）+key）异或明文3\n\nCTR\n（iv+key)异或明文1 （（iv+1）+key)异或明文1    （（（iv+1）+1）+key）异或明文3\n\n优点：由于加解密可以并行，因此CTR模式的加解密速度也很快\n\n缺点：iv+1的获取比较负责，需要获取瞬时iv\n\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"hljs language-xquery\">** ECB模式（默认）电码本模式 Electronic Codebook Book\n\n这个模式是默认的，就只是根据密钥的位数，将数据分成不同的块进行加密，加密完成后，再将加密后的数据拼接起来，过程如下：\n\n明文（<span class=\"hljs-number\">64</span>字节） 密钥（<span class=\"hljs-number\">16</span>字节）\n\n明文<span class=\"hljs-number\">1</span>（<span class=\"hljs-number\">16</span>字节）  明文<span class=\"hljs-number\">2</span>（<span class=\"hljs-number\">16</span>字节）  明文<span class=\"hljs-number\">3</span>（<span class=\"hljs-number\">16</span>字节）  明文<span class=\"hljs-number\">4</span>（<span class=\"hljs-number\">16</span>字节）\n\n密文<span class=\"hljs-number\">1</span>（<span class=\"hljs-number\">16</span>字节）  密文<span class=\"hljs-number\">2</span>（<span class=\"hljs-number\">16</span>字节）  密文<span class=\"hljs-number\">3</span>（<span class=\"hljs-number\">16</span>字节）  密文<span class=\"hljs-number\">4</span>（<span class=\"hljs-number\">16</span>字节）\n\n密文（<span class=\"hljs-number\">64</span>字节）\n\n优点：简单、速度快、可并行\n缺点：如果明文块相同，则生成的密文块也相同，这样会导致安全性降低\n\n\n** CBC模式   密码分组链接模式 Cipher Block Chaining\n\n为了解决ECB模式的密文块相同的缺点，CBC的模式引入了一个初始向量概念，该向量必须是一个与密钥长度相等的数据，在第一次加密前，会使用初始化向量与第一块数据做异或运算，生成的新数据再进行加密，加密第二块之前，会拿第一块的密文数据与第二块明文进行异或运算后再进行加密，以此类推，解密时也是在解密后，进行异或运算，生成最终的明文。过程如下：\n\n明文（<span class=\"hljs-number\">63</span>字节） 密钥 （<span class=\"hljs-number\">16</span>字节） 初始向量iv（<span class=\"hljs-number\">16</span>字节）\n\n  明文<span class=\"hljs-number\">1</span>（<span class=\"hljs-number\">16</span>字节） 明文<span class=\"hljs-number\">2</span>（<span class=\"hljs-number\">16</span>字节） 明文<span class=\"hljs-number\">3</span>（<span class=\"hljs-number\">16</span>字节） 明文<span class=\"hljs-number\">4</span>+一个<span class=\"hljs-number\">0</span>（<span class=\"hljs-number\">16</span>字节） \n\n异或  +初始向量        +密文<span class=\"hljs-number\">1</span>         +密文<span class=\"hljs-number\">2</span>         +密文<span class=\"hljs-number\">3</span>\n\n  密文<span class=\"hljs-number\">1</span>（<span class=\"hljs-number\">16</span>字节） 密文<span class=\"hljs-number\">2</span>（<span class=\"hljs-number\">16</span>字节） 密文<span class=\"hljs-number\">3</span>（<span class=\"hljs-number\">16</span>字节） 密文<span class=\"hljs-number\">4</span>（<span class=\"hljs-number\">16</span>字节） \n\n密文（<span class=\"hljs-number\">64</span>字节）\n\n这里需要注意如下几点：\n<span class=\"hljs-number\">1</span>.向量必须是一个与密钥长度相等的数据\n<span class=\"hljs-number\">2</span>.由于在加密前和解密后都会做异或运算，因此我们的明文可以不用补全，不是<span class=\"hljs-number\">16</span>个字节的倍数也可以，CBC中会自动用<span class=\"hljs-number\">0</span>补全进行异或运算\n<span class=\"hljs-number\">3</span>.在解密时是解密后才会再做异或运算，保证数据解密成功\n<span class=\"hljs-number\">4</span>.由于自动进行了补全，所以解密出的数据也会在后面补全<span class=\"hljs-number\">0</span>，因此获取到数据时，需要将末尾的<span class=\"hljs-number\">0</span>去除，或者根据源数据长度来截取解密后的数据\n\n优点：每次加密密钥不同，加强了安全性\n\nCBC的方式解决了EBC的缺点，但是也有其缺点：\n<span class=\"hljs-number\">1</span>.加密无法并行运算，但是解密可以并行，必须在前一个块加密完成后，才能加密后块，并且也需要填充<span class=\"hljs-number\">0</span>在后面，所以并不适合流数据（不适合的原因可能是，需要满足<span class=\"hljs-number\">128</span>位的数据之后才能进行加密，这样后面才不会有<span class=\"hljs-number\">0</span>的补全）\n<span class=\"hljs-number\">2</span>.如果前一个数据加密错误，那么后续的数据都是错的了\n<span class=\"hljs-number\">3</span>.两端需要同时约定初始向量iv\n\n\n** CFB模式： 密码反馈模式 Cipher FeedBack\n这个模式只使用了加密方法，原理是用到了一个数值异或运算之后再进行一次异或运算，值不改变的原理。并且在加密的时候，如果数据并不满足一个密钥的字节，那么只做保存，待满足一个密钥的字节后再进行加密 过程如下：\n\n加密：\n\n明文（<span class=\"hljs-number\">260</span>个字节） iv（<span class=\"hljs-number\">128</span>个字节）\n\n明文<span class=\"hljs-number\">1</span>（<span class=\"hljs-number\">128</span>个字节）    明文<span class=\"hljs-number\">2</span>（<span class=\"hljs-number\">128</span>个字节）      明文<span class=\"hljs-number\">3</span>（<span class=\"hljs-number\">4</span>个字节）\n\n（iv<span class=\"hljs-built_in\">+key</span>）异或 明文<span class=\"hljs-number\">1</span> （密文<span class=\"hljs-number\">1</span><span class=\"hljs-built_in\">+key</span>）异或 明文<span class=\"hljs-number\">1</span>  （密文<span class=\"hljs-number\">1</span><span class=\"hljs-built_in\">+key</span>）异或明文<span class=\"hljs-number\">3</span>\n\n密文<span class=\"hljs-number\">1</span>（<span class=\"hljs-number\">128</span>个字节）     密文<span class=\"hljs-number\">2</span>（<span class=\"hljs-number\">128</span>个字节）      密文<span class=\"hljs-number\">3</span>（<span class=\"hljs-number\">4</span>个字节）\n\n\n解密：\n\n密文（<span class=\"hljs-number\">260</span>个字节） iv（<span class=\"hljs-number\">128</span>个字节）密钥（<span class=\"hljs-number\">128</span>字节）\n\n密文<span class=\"hljs-number\">1</span>（<span class=\"hljs-number\">128</span>个字节）      密文<span class=\"hljs-number\">2</span>（<span class=\"hljs-number\">128</span>个字节）      密文<span class=\"hljs-number\">3</span>（<span class=\"hljs-number\">4</span>个字节）\n\n（iv<span class=\"hljs-built_in\">+key</span>）异或密文<span class=\"hljs-number\">1</span>   （密文<span class=\"hljs-number\">1</span><span class=\"hljs-built_in\">+key</span>）异或密文<span class=\"hljs-number\">2</span>    （密文<span class=\"hljs-number\">1</span><span class=\"hljs-built_in\">+key</span>）异或密文<span class=\"hljs-number\">3</span>\n\n明文<span class=\"hljs-number\">1</span> （<span class=\"hljs-number\">128</span>个字节）     明文<span class=\"hljs-number\">2</span>  （<span class=\"hljs-number\">128</span>个字节）      明文<span class=\"hljs-number\">3</span>（<span class=\"hljs-number\">4</span>个字节）\n\n这里需要注意如下几点：\n<span class=\"hljs-number\">1</span>.加解密时会返回一个num，这个num表示还需要几个数字，才会使用上一个密文加密，否则一直使用上上一个\n<span class=\"hljs-number\">2</span>.加解密时也需要传入字符串的长度\n<span class=\"hljs-number\">3</span>.由于解密时使用的都是密文来进行解密，并没有使用上一次解密的明文，因此解密也可以并行\n<span class=\"hljs-number\">4</span>.由于CFB模式并不需要补全，或者一个完整的<span class=\"hljs-number\">128</span>字节才能加解密，综合第三点，所以适合流数据的传输。\n<span class=\"hljs-number\">5</span>.CFB模式不止有CFB128（即与密钥长度一致），还有CFB1 和CFB8 即加解密<span class=\"hljs-number\">1</span>或<span class=\"hljs-number\">8</span>位后，再调用一次加密器生成新的值，这样可以使加密更安全，但是就会处理更多的运算，CFB1的运算时间是CFB8的八倍 CFB128的<span class=\"hljs-number\">128</span>倍\n<span class=\"hljs-number\">6</span>.使用CFB128或者CFB8的时候传入的length单位是字节，CFB1是length的单位是位。\n<span class=\"hljs-number\">7</span>.使用CFB1和CFB8的时候，num值会始终为<span class=\"hljs-number\">0</span>\n\n优点:解密可同步，可以传入非<span class=\"hljs-number\">16</span>字节倍数的数据，适合流数据\n\nCFB模式当然也有一个缺点，解密的时候可以并行解密，但是加密的时候并不可以并行加密。并且也需要选择iv\n\n\n** OFB模式： 输出反馈模式 Output FeedBack\n该模式与CFB类似，但是是将iv或者上一个iv加密后的数据加密，生成<span class=\"hljs-built_in\">的key</span>与明文做异或运算，解密时采用的是同样的方法，利用了异或运算的对称性来进行加解密，除了这一点，其余与CFB一致\n\n加密/解密：\n\nCFB:\n（iv<span class=\"hljs-built_in\">+key</span>）异或 明文<span class=\"hljs-number\">1</span> （密文<span class=\"hljs-number\">1</span><span class=\"hljs-built_in\">+key</span>）异或 明文<span class=\"hljs-number\">1</span>       （密文<span class=\"hljs-number\">1</span><span class=\"hljs-built_in\">+key</span>）异或明文<span class=\"hljs-number\">3</span>\n\nOFB\n（iv<span class=\"hljs-built_in\">+key</span>)异或明文<span class=\"hljs-number\">1</span> （（iv<span class=\"hljs-built_in\">+key</span>）<span class=\"hljs-built_in\">+key</span>)异或明文<span class=\"hljs-number\">1</span>  （（（iv<span class=\"hljs-built_in\">+key</span>）<span class=\"hljs-built_in\">+key</span>）<span class=\"hljs-built_in\">+key</span>）异或明文<span class=\"hljs-number\">3</span>\n\n优点：与CFB一样，方便传输流数据\n\n缺点：由于依赖上一次的加密结果，所以并不能并行处理，特性是解密步骤完全一致，因此使用方法上不会有区别。\n\n\n** CTR模式： 计算器模式 Counter\nOFB不能并行的原因就在于需要上一次的iv进行加密后的结果，因此在CTR中我们将（iv<span class=\"hljs-built_in\">+key</span>）<span class=\"hljs-built_in\">+key</span>替换成了（iv+<span class=\"hljs-number\">1</span>）<span class=\"hljs-built_in\">+key</span>,这样我们就不需要依赖上一次的加密结果了。对比如下:\n\nOFB\n（iv<span class=\"hljs-built_in\">+key</span>)异或明文<span class=\"hljs-number\">1</span> （（iv<span class=\"hljs-built_in\">+key</span>）<span class=\"hljs-built_in\">+key</span>)异或明文<span class=\"hljs-number\">1</span>  （（（iv<span class=\"hljs-built_in\">+key</span>）<span class=\"hljs-built_in\">+key</span>）<span class=\"hljs-built_in\">+key</span>）异或明文<span class=\"hljs-number\">3</span>\n\nCTR\n（iv<span class=\"hljs-built_in\">+key</span>)异或明文<span class=\"hljs-number\">1</span> （（iv+<span class=\"hljs-number\">1</span>）<span class=\"hljs-built_in\">+key</span>)异或明文<span class=\"hljs-number\">1</span>    （（（iv+<span class=\"hljs-number\">1</span>）+<span class=\"hljs-number\">1</span>）<span class=\"hljs-built_in\">+key</span>）异或明文<span class=\"hljs-number\">3</span>\n\n优点：由于加解密可以并行，因此CTR模式的加解密速度也很快\n\n缺点：iv+<span class=\"hljs-number\">1</span>的获取比较负责，需要获取瞬时iv\n</pre><p>三、提供两个示例<br>1、java mysql 通用aes加密算法<br>通用的aes加密，使用场景，插入数据时，使用java进行加密数据，查询时，通过sql进行解密，不用取出再遍历解密<br>注：to_base64只适用mysql5.6之后的，之前的没有这个函数，不适用，可以使用HEX，UNHEX ，当然java要用对应的方法解密</p><p>import javax.crypto.Cipher;<br>import javax.crypto.spec.SecretKeySpec;</p><p>import sun.misc.BASE64Decoder;<br>import sun.misc.BASE64Encoder;</p><p>/**</p><ul><li>java使用AES加密解密 AES-128-ECB加密</li><li>与mysql数据库aes加密算法通用</li><li>数据库aes加密解密</li><li>-- 加密</li><li>SELECT to_base64(AES_ENCRYPT('www.gowhere.so','jkl;POIU1234++=='));</li><li>-- 解密</li><li>SELECT AES_DECRYPT(from_base64('Oa1NPBSarXrPH8wqSRhh3g=='),'jkl;POIU1234++==');</li><li>@author 836508<br> *<br> */</li></ul><p>public class MyAESUtil {</p><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"// 加密\npublic static String Encrypt(String sSrc, String sKey) throws Exception {\n    if (sKey == null) {\n        System.out.print(&quot;Key为空null&quot;);\n        return null;\n    }\n    // 判断Key是否为16位\n    if (sKey.length() != 16) {\n        System.out.print(&quot;Key长度不是16位&quot;);\n        return null;\n    }\n    byte[] raw = sKey.getBytes(&quot;utf-8&quot;);\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;);\n    Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);//&quot;算法/模式/补码方式&quot;\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(sSrc.getBytes(&quot;utf-8&quot;));\n    return new BASE64Encoder().encode(encrypted);//此处使用BASE64做转码功能，同时能起到2次加密的作用。\n}\n\n// 解密\npublic static String Decrypt(String sSrc, String sKey) throws Exception {\n    try {\n        // 判断Key是否正确\n        if (sKey == null) {\n            System.out.print(&quot;Key为空null&quot;);\n            return null;\n        }\n        // 判断Key是否为16位\n        if (sKey.length() != 16) {\n            System.out.print(&quot;Key长度不是16位&quot;);\n            return null;\n        }\n        byte[] raw = sKey.getBytes(&quot;utf-8&quot;);\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;);\n        Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] encrypted1 = new BASE64Decoder().decodeBuffer(sSrc);//先用base64解密\n        try {\n            byte[] original = cipher.doFinal(encrypted1);\n            String originalString = new String(original,&quot;utf-8&quot;);\n            return originalString;\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            return null;\n        }\n    } catch (Exception ex) {\n        System.out.println(ex.toString());\n        return null;\n    }\n}\n\npublic static void main(String[] args) throws Exception {\n    /*\n     * 此处使用AES-128-ECB加密模式，key需要为16位。\n     */\n    String cKey = &quot;jkl;POIU1234++==&quot;;\n    // 需要加密的字串\n    String cSrc = &quot;www.gowhere.so&quot;;\n    System.out.println(cSrc);\n    // 加密\n    String enString = MyAESUtil.Encrypt(cSrc, cKey);\n    System.out.println(&quot;加密后的字串是：&quot; + enString);\n\n    // 解密\n    String DeString = MyAESUtil.Decrypt(enString, cKey);\n    System.out.println(&quot;解密后的字串是：&quot; + DeString);\n}\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"hljs language-pgsql\">// 加密\n<span class=\"hljs-built_in\">public</span> static String Encrypt(String sSrc, String sKey) throws <span class=\"hljs-keyword\">Exception</span> {\n    <span class=\"hljs-keyword\">if</span> (sKey == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.print(\"Key为空null\");\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    }\n    // 判断Key是否为<span class=\"hljs-number\">16</span>位\n    <span class=\"hljs-keyword\">if</span> (sKey.length() != <span class=\"hljs-number\">16</span>) {\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.print(\"Key长度不是16位\");\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    }\n    byte[] raw = sKey.getBytes(\"utf-8\");\n    SecretKeySpec skeySpec = <span class=\"hljs-built_in\">new</span> SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");//\"算法/模式/补码方式\"\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] <span class=\"hljs-keyword\">encrypted</span> = cipher.doFinal(sSrc.getBytes(\"utf-8\"));\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">new</span> BASE64Encoder().encode(<span class=\"hljs-keyword\">encrypted</span>);//此处使用BASE64做转码功能，同时能起到<span class=\"hljs-number\">2</span>次加密的作用。\n}\n\n// 解密\n<span class=\"hljs-built_in\">public</span> static String Decrypt(String sSrc, String sKey) throws <span class=\"hljs-keyword\">Exception</span> {\n    try {\n        // 判断Key是否正确\n        <span class=\"hljs-keyword\">if</span> (sKey == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.print(\"Key为空null\");\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n        }\n        // 判断Key是否为<span class=\"hljs-number\">16</span>位\n        <span class=\"hljs-keyword\">if</span> (sKey.length() != <span class=\"hljs-number\">16</span>) {\n            <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.print(\"Key长度不是16位\");\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n        }\n        byte[] raw = sKey.getBytes(\"utf-8\");\n        SecretKeySpec skeySpec = <span class=\"hljs-built_in\">new</span> SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] encrypted1 = <span class=\"hljs-built_in\">new</span> BASE64Decoder().decodeBuffer(sSrc);//先用base64解密\n        try {\n            byte[] original = cipher.doFinal(encrypted1);\n            String originalString = <span class=\"hljs-built_in\">new</span> String(original,\"utf-8\");\n            <span class=\"hljs-keyword\">return</span> originalString;\n        } catch (<span class=\"hljs-keyword\">Exception</span> e) {\n            <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(e.toString());\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n        }\n    } catch (<span class=\"hljs-keyword\">Exception</span> ex) {\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(ex.toString());\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    }\n}\n\n<span class=\"hljs-built_in\">public</span> static <span class=\"hljs-type\">void</span> main(String[] args) throws <span class=\"hljs-keyword\">Exception</span> {\n    <span class=\"hljs-comment\">/*\n     * 此处使用AES-128-ECB加密模式，key需要为16位。\n     */</span>\n    String cKey = \"jkl;POIU1234++==\";\n    // 需要加密的字串\n    String cSrc = \"www.gowhere.so\";\n    <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(cSrc);\n    // 加密\n    String enString = MyAESUtil.Encrypt(cSrc, cKey);\n    <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(\"加密后的字串是：\" + enString);\n\n    // 解密\n    String DeString = MyAESUtil.Decrypt(enString, cKey);\n    <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(\"解密后的字串是：\" + DeString);\n}</pre><p>}<br>2、java  AES-128-CBC加密模式<br>package com.zhongzhi.utils;<br>import javax.crypto.Cipher;<br>import javax.crypto.spec.IvParameterSpec;<br>import javax.crypto.spec.SecretKeySpec;<br>import org.apache.commons.codec.binary.Base64;<br>/**</p><ul><li>@Classname ZzSecurityHelper</li><li>@Description TODO</li><li>@Date 2019/6/24 16:50</li><li>@Created by whd<br> */</li></ul><p>public class ZzSecurityHelper {</p><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"/*\n * 加密用的Key 可以用26个字母和数字组成 使用AES-128-CBC加密模式，key需要为16位。\n */\nprivate static final String key=&quot;hj7x89H$yuBI0456&quot;;\nprivate static final String iv =&quot;NIfb&amp;95GUY86Gfgh&quot;;\n/**\n * @author miracle.qu\n * @Description AES算法加密明文\n * @param data 明文\n * @param key 密钥，长度16\n * @param iv 偏移量，长度16\n * @return 密文\n */\npublic static String encryptAES(String data) throws Exception {\n    try {\n        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);\n        int blockSize = cipher.getBlockSize();\n        byte[] dataBytes = data.getBytes();\n        int plaintextLength = dataBytes.length;\n\n        if (plaintextLength % blockSize != 0) {\n            plaintextLength = plaintextLength + (blockSize - (plaintextLength % blockSize));\n        }\n\n        byte[] plaintext = new byte[plaintextLength];\n        System.arraycopy(dataBytes, 0, plaintext, 0, dataBytes.length);\n\n        SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), &quot;AES&quot;);\n        IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());  // CBC模式，需要一个向量iv，可增加加密算法的强度\n\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n        byte[] encrypted = cipher.doFinal(plaintext);\n\n        return ZzSecurityHelper.encode(encrypted).trim(); // BASE64做转码。\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n}\n\n/**\n * @author miracle.qu\n * @Description AES算法解密密文\n * @param data 密文\n * @param key 密钥，长度16\n * @param iv 偏移量，长度16\n * @return 明文\n */\npublic static String decryptAES(String data) throws Exception {\n    try\n    {\n        byte[] encrypted1 = ZzSecurityHelper.decode(data);//先用base64解密\n\n        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);\n        SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), &quot;AES&quot;);\n        IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n        byte[] original = cipher.doFinal(encrypted1);\n        String originalString = new String(original);\n        return originalString.trim();\n    }\n    catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n}\n/**\n * 编码\n * @param byteArray\n * @return\n */\npublic static String encode(byte[] byteArray) {\n    return new String(new Base64().encode(byteArray));\n}\n\n/**\n * 解码\n * @param base64EncodedString\n * @return\n */\npublic static byte[] decode(String base64EncodedString) {\n    return new Base64().decode(base64EncodedString);\n}\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"hljs language-java\"><span class=\"hljs-comment\">/*\n * 加密用的Key 可以用26个字母和数字组成 使用AES-128-CBC加密模式，key需要为16位。\n */</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String key=<span class=\"hljs-string\">\"hj7x89H$yuBI0456\"</span>;\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">iv</span> <span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"NIfb&amp;95GUY86Gfgh\"</span>;\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@author</span> miracle.qu\n * <span class=\"hljs-doctag\">@Description</span> AES算法加密明文\n * <span class=\"hljs-doctag\">@param</span> data 明文\n * <span class=\"hljs-doctag\">@param</span> key 密钥，长度16\n * <span class=\"hljs-doctag\">@param</span> iv 偏移量，长度16\n * <span class=\"hljs-doctag\">@return</span> 密文\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">encryptAES</span><span class=\"hljs-params\">(String data)</span> <span class=\"hljs-keyword\">throws</span> Exception {\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-type\">Cipher</span> <span class=\"hljs-variable\">cipher</span> <span class=\"hljs-operator\">=</span> Cipher.getInstance(<span class=\"hljs-string\">\"AES/CBC/NoPadding\"</span>);\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">blockSize</span> <span class=\"hljs-operator\">=</span> cipher.getBlockSize();\n        <span class=\"hljs-type\">byte</span>[] dataBytes = data.getBytes();\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">plaintextLength</span> <span class=\"hljs-operator\">=</span> dataBytes.length;\n\n        <span class=\"hljs-keyword\">if</span> (plaintextLength % blockSize != <span class=\"hljs-number\">0</span>) {\n            plaintextLength = plaintextLength + (blockSize - (plaintextLength % blockSize));\n        }\n\n        <span class=\"hljs-type\">byte</span>[] plaintext = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">byte</span>[plaintextLength];\n        System.arraycopy(dataBytes, <span class=\"hljs-number\">0</span>, plaintext, <span class=\"hljs-number\">0</span>, dataBytes.length);\n\n        <span class=\"hljs-type\">SecretKeySpec</span> <span class=\"hljs-variable\">keyspec</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SecretKeySpec</span>(key.getBytes(), <span class=\"hljs-string\">\"AES\"</span>);\n        <span class=\"hljs-type\">IvParameterSpec</span> <span class=\"hljs-variable\">ivspec</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IvParameterSpec</span>(iv.getBytes());  <span class=\"hljs-comment\">// CBC模式，需要一个向量iv，可增加加密算法的强度</span>\n\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n        <span class=\"hljs-type\">byte</span>[] encrypted = cipher.doFinal(plaintext);\n\n        <span class=\"hljs-keyword\">return</span> ZzSecurityHelper.encode(encrypted).trim(); <span class=\"hljs-comment\">// BASE64做转码。</span>\n\n    } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n        e.printStackTrace();\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@author</span> miracle.qu\n * <span class=\"hljs-doctag\">@Description</span> AES算法解密密文\n * <span class=\"hljs-doctag\">@param</span> data 密文\n * <span class=\"hljs-doctag\">@param</span> key 密钥，长度16\n * <span class=\"hljs-doctag\">@param</span> iv 偏移量，长度16\n * <span class=\"hljs-doctag\">@return</span> 明文\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">decryptAES</span><span class=\"hljs-params\">(String data)</span> <span class=\"hljs-keyword\">throws</span> Exception {\n    <span class=\"hljs-keyword\">try</span>\n    {\n        <span class=\"hljs-type\">byte</span>[] encrypted1 = ZzSecurityHelper.decode(data);<span class=\"hljs-comment\">//先用base64解密</span>\n\n        <span class=\"hljs-type\">Cipher</span> <span class=\"hljs-variable\">cipher</span> <span class=\"hljs-operator\">=</span> Cipher.getInstance(<span class=\"hljs-string\">\"AES/CBC/NoPadding\"</span>);\n        <span class=\"hljs-type\">SecretKeySpec</span> <span class=\"hljs-variable\">keyspec</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SecretKeySpec</span>(key.getBytes(), <span class=\"hljs-string\">\"AES\"</span>);\n        <span class=\"hljs-type\">IvParameterSpec</span> <span class=\"hljs-variable\">ivspec</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IvParameterSpec</span>(iv.getBytes());\n\n        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n        <span class=\"hljs-type\">byte</span>[] original = cipher.doFinal(encrypted1);\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">originalString</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(original);\n        <span class=\"hljs-keyword\">return</span> originalString.trim();\n    }\n    <span class=\"hljs-keyword\">catch</span> (Exception e) {\n        e.printStackTrace();\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n    }\n}\n<span class=\"hljs-comment\">/**\n * 编码\n * <span class=\"hljs-doctag\">@param</span> byteArray\n * <span class=\"hljs-doctag\">@return</span>\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">encode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">byte</span>[] byteArray)</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Base64</span>().encode(byteArray));\n}\n\n<span class=\"hljs-comment\">/**\n * 解码\n * <span class=\"hljs-doctag\">@param</span> base64EncodedString\n * <span class=\"hljs-doctag\">@return</span>\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">byte</span>[] decode(String base64EncodedString) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Base64</span>().decode(base64EncodedString);\n}</pre><p>}</p>","type":["javascript"],"time":"2021-11-05T11:50:01.000Z","href":"https://segmentfault.com/a/1190000040918143"},{"title":"null","html":"<h2 id=\"item-1\">toLocaleString()，直接上代码</h2><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"var num = 1234567\nnum = num.toLocaleString()\nconsole.log(num)\n// 打印结果：1,234,567\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"js hljs language-javascript\"><span class=\"hljs-keyword\">var</span> num = <span class=\"hljs-number\">1234567</span>\nnum = num.<span class=\"hljs-title function_\">toLocaleString</span>()\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(num)\n<span class=\"hljs-comment\">// 打印结果：1,234,567</span></pre><p>结束。</p><hr><h4>顺便看一下它的其他用法</h4><ul><li>转换时间格式</li></ul><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"var d = new Date();\nvar n = d.toLocaleString();\nconsole.log(n)\n// 打印结果：2021/11/5 下午5:27:20\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"js hljs language-javascript\"><span class=\"hljs-keyword\">var</span> d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>();\n<span class=\"hljs-keyword\">var</span> n = d.<span class=\"hljs-title function_\">toLocaleString</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(n)\n<span class=\"hljs-comment\">// 打印结果：2021/11/5 下午5:27:20</span></pre><ul><li>把数组转换为本地字符串。</li></ul><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"var a = ['1', '2', '3'];\nconsole.log(a.toLocaleString());\n// 打印结果：1,2,3\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"js hljs language-javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">'1'</span>, <span class=\"hljs-string\">'2'</span>, <span class=\"hljs-string\">'3'</span>];\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">toLocaleString</span>());\n<span class=\"hljs-comment\">// 打印结果：1,2,3</span></pre><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"var a = [1, 2, 3];\nconsole.log(a.toLocaleString());\n// 打印结果：1,2,3\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"js hljs language-javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">toLocaleString</span>());\n<span class=\"hljs-comment\">// 打印结果：1,2,3</span></pre><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"var a = [\n    { x: 1 },\n    { y: 2 },\n    { z: 3 }\n];\nconsole.log(a.toLocaleString());\n// 打印结果：[object Object],[object Object],[object Object]\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"js hljs language-javascript\"><span class=\"hljs-keyword\">var</span> a = [\n    { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span> },\n    { <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span> },\n    { <span class=\"hljs-attr\">z</span>: <span class=\"hljs-number\">3</span> }\n];\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">toLocaleString</span>());\n<span class=\"hljs-comment\">// 打印结果：[object Object],[object Object],[object Object]</span></pre>","type":["javascript","前端"],"time":"2021-11-05T09:37:18.000Z","href":"https://segmentfault.com/a/1190000040917699"},{"title":"null","html":"<p>在开发中遇到ZIP 压缩包文件下载的需求，在此记录一下。<br>我这里是有后端返回 ZIP 的流文件。才用了如下方法处理。</p><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"this.$api.gameApi.downloadZIP(this.gameInformation.id,row.id).then(res => {\n      const blob = new Blob([res.data], {type: 'application/zip'})\n      const url = window.URL.createObjectURL(blob)\n      const link = document.createElement('a') // 创建a标签\n      link.href = url\n      link.download = row.name // 重命名文件\n      link.click()\n      URL.revokeObjectURL(url) // 释放内存\n  })\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"js hljs language-javascript\"><span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$api</span>.<span class=\"hljs-property\">gameApi</span>.<span class=\"hljs-title function_\">downloadZIP</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">gameInformation</span>.<span class=\"hljs-property\">id</span>,row.<span class=\"hljs-property\">id</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> blob = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Blob</span>([res.<span class=\"hljs-property\">data</span>], {<span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'application/zip'</span>})\n      <span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">URL</span>.<span class=\"hljs-title function_\">createObjectURL</span>(blob)\n      <span class=\"hljs-keyword\">const</span> link = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">'a'</span>) <span class=\"hljs-comment\">// 创建a标签</span>\n      link.<span class=\"hljs-property\">href</span> = url\n      link.<span class=\"hljs-property\">download</span> = row.<span class=\"hljs-property\">name</span> <span class=\"hljs-comment\">// 重命名文件</span>\n      link.<span class=\"hljs-title function_\">click</span>()\n      <span class=\"hljs-variable constant_\">URL</span>.<span class=\"hljs-title function_\">revokeObjectURL</span>(url) <span class=\"hljs-comment\">// 释放内存</span>\n  })</pre><p>单纯这么使用，下载下来的压缩包打不开，需要对 <code>axios</code> 进行如下配置</p><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\" downloadZIP(id, bundlesId) {\n    return $axios({\n      methods: &quot;get&quot;,\n      url: `/v1/${id}/material/bundle/${bundlesId}`,\n      responseType: 'blob'\n    })\n  },\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"js hljs language-javascript\"> <span class=\"hljs-title function_\">downloadZIP</span>(<span class=\"hljs-params\">id, bundlesId</span>) {\n    <span class=\"hljs-keyword\">return</span> $axios({\n      <span class=\"hljs-attr\">methods</span>: <span class=\"hljs-string\">\"get\"</span>,\n      <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`/v1/<span class=\"hljs-subst\">${id}</span>/material/bundle/<span class=\"hljs-subst\">${bundlesId}</span>`</span>,\n      <span class=\"hljs-attr\">responseType</span>: <span class=\"hljs-string\">'blob'</span>\n    })\n  },</pre><p>添加： <code> responseType: 'blob'</code> 即可。</p>","type":["javascript"],"time":"2021-11-05T08:53:33.000Z","href":"https://segmentfault.com/a/1190000040917437"},{"title":"null","html":"<h3 id=\"item-1\">手机调试</h3><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"<!--手机调试--> \n<% if (VUE_APP_ERUDA === 'true') { %>\n    <script src=&quot;//cdn.bootcss.com/eruda/1.5.2/eruda.min.js&quot;></script>\n    <script>\n      window.eruda.init()\n    </script>\n<% } %>\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"hljs language-erb\"><span class=\"language-xml\"><span class=\"hljs-comment\">&lt;!--手机调试--&gt;</span> \n&lt;%</span><span class=\"language-ruby\"> <span class=\"hljs-keyword\">if</span> (VUE_APP_ERUDA === <span class=\"hljs-string\">'true'</span>) { </span><span class=\"language-xml\">%&gt;\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"//cdn.bootcss.com/eruda/1.5.2/eruda.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n      <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">eruda</span>.<span class=\"hljs-title function_\">init</span>()\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n&lt;%</span><span class=\"language-ruby\"> } </span><span class=\"language-xml\">%&gt;</span></pre><h3 id=\"item-2\">手机调试</h3><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"<meta charset=&quot;utf-8&quot; />\n<meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; />\n<meta name=&quot;viewport&quot;\n      content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0,viewport-fit=cover&quot;\n    />\n<meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; />\n<meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; />\n<meta content=&quot;telephone=no,email=no&quot; name=&quot;format-detection&quot; />\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"hljs language-abnf\">&lt;meta charset<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"utf-8\"</span> /&gt;\n&lt;meta http-equiv<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"X-UA-Compatible\"</span> content<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"IE=edge\"</span> /&gt;\n&lt;meta name<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"viewport\"</span>\n      content<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0,viewport-fit=cover\"</span>\n    /&gt;\n&lt;meta name<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"apple-mobile-web-app-capable\"</span> content<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"yes\"</span> /&gt;\n&lt;meta name<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"apple-mobile-web-app-status-bar-style\"</span> content<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"black\"</span> /&gt;\n&lt;meta content<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"telephone=no,email=no\"</span> name<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">\"format-detection\"</span> /&gt;</pre>","type":["vue.js","javascript"],"time":"2021-11-05T08:27:07.000Z","href":"https://segmentfault.com/a/1190000040917184"},{"title":"null","html":"<p>download(name, url) {</p><div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"  const ele = document.createElement(&quot;a&quot;);\n  ele.setAttribute(&quot;href&quot;, url);\n  ele.setAttribute(&quot;target&quot;, &quot;_blank&quot;);\n  ele.setAttribute(&quot;download&quot;, name);\n  ele.style.display = &quot;none&quot;;\n  document.body.appendChild(ele);\n  ele.click();\n  document.body.removeChild(ele);\n},\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"hljs language-reasonml\">  const ele = document.create<span class=\"hljs-constructor\">Element(<span class=\"hljs-string\">\"a\"</span>)</span>;\n  ele.set<span class=\"hljs-constructor\">Attribute(<span class=\"hljs-string\">\"href\"</span>, <span class=\"hljs-params\">url</span>)</span>;\n  ele.set<span class=\"hljs-constructor\">Attribute(<span class=\"hljs-string\">\"target\"</span>, <span class=\"hljs-string\">\"_blank\"</span>)</span>;\n  ele.set<span class=\"hljs-constructor\">Attribute(<span class=\"hljs-string\">\"download\"</span>, <span class=\"hljs-params\">name</span>)</span>;\n  ele.style.display = <span class=\"hljs-string\">\"none\"</span>;\n  document.body.append<span class=\"hljs-constructor\">Child(<span class=\"hljs-params\">ele</span>)</span>;\n  ele.click<span class=\"hljs-literal\">()</span>;\n  document.body.remove<span class=\"hljs-constructor\">Child(<span class=\"hljs-params\">ele</span>)</span>;\n},</pre>","type":["javascript","前端"],"time":"2021-11-05T08:04:48.000Z","href":"https://segmentfault.com/a/1190000040917015"},{"title":"null","html":"<div class=\"widget-codetool\" style=\"display:none;\">\n        <div class=\"widget-codetool--inner\">\n        <button type=\"button\" class=\"btn btn-dark far fa-copy rounded-0 sflex-center copyCode\" data-toggle=\"tooltip\" data-placement=\"top\" data-clipboard-text=\"   Object.keys(fieldValue).map((item) => {\n          if (!fieldValue[item] || fieldValue[item].length == 0) {\n            delete fieldValue[item]\n          }\n        })\" title=\"\" data-original-title=\"复制\"></button>\n        </div>\n        </div><pre class=\"hljs language-xquery\">   Object.keys(fieldValue).<span class=\"hljs-keyword\">map</span>((<span class=\"hljs-type\">item</span>) =&gt; {\n          <span class=\"hljs-keyword\">if</span> (!fieldValue[<span class=\"hljs-type\">item</span>] || fieldValue[<span class=\"hljs-type\">item</span>].length == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">delete</span> fieldValue[<span class=\"hljs-type\">item</span>]\n          }\n        })</pre>","type":["javascript"],"time":"2021-11-05T06:58:57.000Z","href":"https://segmentfault.com/a/1190000040916385"}]}